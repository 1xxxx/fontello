var myapp = (function () {

    var cfg = {
        id: {
            tab: "#tab",
            notification: "#notifications-container",

            bad_browser: "#fm-bad-browser",
            glyph_count: "#fm-glyph-count",

            file: "#fm-file",
            file_browse_button: "#fm-file-browse-button",
            file_drop_zone: "#fm-file-drop-zone",

            icon_size: "#fm-icon-size",
            use_embedded: "#fm-use-embedded",

            tab_save: "#fm-tab-save",

            tab1_content: "#fm-tab1-content",
            tab2_content: "#fm-tab2-content",

            form_charset: "#fm-form-charset",

            font: "#fm-font",
            download_font_button: "#fm-download-font-button",
            icon_assignments: "#fm-icon-assignments",

            font_output: "#fm-font-output"
        },
        class: {
            glyph_group: ".fm-glyph-group",
            disable_on_demand: ".fm-disable-on-demand"
        },
        template: {
            icon_size_button: { id: "#fm-tpl-icon-size-button" },
            embedded: { id: "#fm-tpl-embedded" },
            glyph: { id: "#fm-tpl-glyph" },
            glyph_group: { id: "#fm-tpl-glyph-group" },
            font: { id: "#fm-tpl-font" },
            rearrange_glyph: { id: "#fm-tpl-rearrange-glyph" }
        },

        // class icon_size_prefix+"-<num>" added when icon size has changed
        icon_size_prefix: "fm-icon-size-",
        icon_size_classes: "", // precalculated by initGlobals()

        preview_icon_sizes: [32, 24, 16],
        live_update: true,
        fix_edges: true,
        scale_precision: 6, // truncate the mantissa when scaling svg paths
        basic_latin: {
            str: "",    // precalculated by initGlobals()
            begin: 33,
            end: 126,
            extra: " ",
        },
        unicode_private: {
            begin: 0xf0000,
            end: 0xf005e
        },
        draggable_options: {
            revert: "invalid",
            cursor: "move",
            helper: "clone",
            opacity: 0.5,
            disabled: false
        },
        droppable_options: {
            hoverClass: "fm-drop-hover",
            tolerance: "pointer"
        },
        path_options: {
            fill: "#000",
            stroke: "#000",
            "stroke-width": 0
        },
        zero_clipboard: {
            swf_path: "img/ZeroClipboard.swf",

            links: [
                {
                    link: "fm-clipboard-link",
                    span: "fm-clipboard-span",
                    target: "font"
                },
                {
                    link: "fm-clipboard-link2",
                    span: "fm-clipboard-span2",
                    target: "icon_assignments"
                }
            ]
        },
        notify: {
            dup: {},    // for suppressing duplicates

            // notication types
            info: {
                tpl: "basic-template",
                tpl_vars: {},
                opts: { expires: 4000 },
            },
            alert: {
                tpl: "icon-template",
                tpl_vars: { icon: "img/alert.png" },
                opts: { expires: 4000 }
            }
        },
        output: {
            filename: "fontomas.svg",
            font_id: "FontomasCustom",
            horiz_adv_x: 500,
            units_per_em: 1000,
            ascent: 750,
            descent: -250,
            metadata: "This is a custom SVG font generated by Fontomas",
            missing_glyph_horiz_adv_x: 500
        }
    };

    // environment
    var env = {
        flash_version: swfobject.getFlashPlayerVersion(),
        is_file_proto: (window.location.protocol == "file:"),
        filereader: null,
        indexeddb: null,
        localstorage: null
    };

    var myfiles = [];
    var myglyphs = [];
    var glyph_count = 0;
    var xml_template = null;
    var next_glyph_id = 0;

    var debug = {
        is_on: false
    };

    var init = function () {
        initDebug();

        // check browser's capabilities
        if (!isOkBrowser()) {
            console.log("bad browser");
            $(cfg.id.bad_browser).modal({keyboard: false});
            return;
        };

        initGlobals();

        // show loading tab
        $(cfg.id.tab).tab("show");

        initSelectTab();

        // first tab is fully initialized so show it
        $(cfg.id.tab+" a:first").tab("show");

        initRearrangeTab();

        initSaveTab();
    };

    // usage: index.html#debug:maxglyphs=10,noembedded,noflash,nofilereader
    var initDebug = function () {
        var hash = window.location.hash.substr(1);
        var params = hash.split("&");
        for (var i=0, len=params.length; i<len; i++) {
            if (params[i].split(":").indexOf("debug") == 0) {
                debug.is_on = true;
                var vars = params[i].split(":")[1].split(",");
                for (var i=0, len=vars.length; i<len; i++) {
                    var pair = vars[i].split("=");
                    debug[pair[0]] = pair[1] && pair[1] !== "" ? pair[1] : true;
                }
                break;
            }
        }

        // debug: simulate no flash plugin installed
        if (debug.is_on && debug.noflash)
            for (var key in env.flash_version)
                env.flash_version[key] = 0;
    };

    var initGlobals = function () {
        // init icon_size_classes
        cfg.icon_size_classes = cfg.preview_icon_sizes.map(function (item) {
            return cfg.icon_size_prefix+item;
        }).join(" ");

        // init cfg.basic_latin.str
        cfg.basic_latin.str = "";
        for (var i=cfg.basic_latin.begin; i<=cfg.basic_latin.end; i++)
            cfg.basic_latin.str += String.fromCharCode(i);
        cfg.basic_latin.str += cfg.basic_latin.extra;

        // init templates
        for (var key in cfg.template) {
            cfg.template[key].tpl = $(cfg.template[key].id).clone()
                .removeAttr("id");
            $(cfg.template[key].id).remove();
        }

        // init output svg template
        try {
            xml_template = $.parseXML($(cfg.id.font_output).html());
        } catch (e) {
            console.log("initGlobals: invalid xml template=",
                $(cfg.id.font_output).html(), "e=", e);
            notify_alert("Internal error: can't parse output template.");
        }
        if (xml_template) {
            $("metadata", xml_template).text(cfg.output.metadata);
            $("font", xml_template).attr({
                id: cfg.output.font_id,
                "horiz-adv-x": cfg.output.horiz_adv_x
            });
            $("font-face", xml_template).attr({
                "units-per-em": cfg.output.units_per_em,
                ascent: cfg.output.ascent,
                descent: cfg.output.descent
            });
            $("missing-glyph", xml_template).attr({
                "horiz-adv-x": cfg.output.missing_glyph_horiz_adv_x
            });
        }

        // init clipboard link targets
        for (var i=0, len=cfg.zero_clipboard.links.length; i<len; i++) {
            var item=cfg.zero_clipboard.links[i];
            item.target = cfg.id[item.target];
        }
    };

    var initSelectTab = function () {
        initFileUpload();

        // init preview icon size selection
        for (var i=0, len=cfg.preview_icon_sizes.length; i<len; i++) {
            var tpl = $(cfg.template.icon_size_button.tpl).clone();
            tpl.toggleClass("active", i == 0);
            tpl.val(cfg.preview_icon_sizes[i]);
            tpl.text(cfg.preview_icon_sizes[i] + "px");
            tpl.click(function (event) {
                event.preventDefault();
                var size = parseInt($(this).val()) || 32;
                console.log('size='+size);
                $(cfg.class.glyph_group).removeClass(cfg.icon_size_classes)
                    .addClass(cfg.icon_size_prefix+size);
                $(cfg.id.tab1_content).find(".gd").each(function (i) {
                    var glyph_id = $(this).siblings(".fm-glyph-id").val();

                    var size_x = myglyphs[glyph_id].glyph_sizes[size][0],
                        size_y = myglyphs[glyph_id].glyph_sizes[size][1];

                    $(this).css({
                            width: size_x + "px",
                            height: size_y + "px",
                            "margin-left": "-" + Math.round(size_x/2) + "px",
                            "margin-top": "-" + Math.round(size_y/2) + "px"
                        })
                        .find("svg").css({
                            width: size_x + "px", 
                            height: size_y + "px"
                        });
                });

                $(cfg.id.tab2_content).removeClass(cfg.icon_size_classes)
                    .addClass(cfg.icon_size_prefix+size);
                $(cfg.id.tab2_content).find(".rg-icon").each(function (i) {
                    var glyph_id = $(this).parent().siblings(".fm-glyph-id")
                        .val();

                    var size_x = size,
                        size_y = size;

                    if (glyph_id != "") {
                        size_x = myglyphs[glyph_id].glyph_sizes[size][0],
                        size_y = myglyphs[glyph_id].glyph_sizes[size][1];
                    }

                    $(this).css({
                            width: size_x + "px",
                            height: size_y + "px",
                            "margin-left": "-" + Math.round(size_x/2) + "px",
                            "margin-top": "-" + Math.round(size_y/2) + "px"
                        })
                        .css({width: "100%", left: "0px", "margin-left": "0px"})
                        .find("svg").css({
                            width: size_x + "px",
                            height: size_y + "px"
                        });
                });
            });
            $(cfg.id.icon_size).append(tpl);
        }

        // init "use embedded" dropdown
        initUseEmbedded();

        // auto load embedded fonts
        // debug
        if (!(debug.is_on && debug.noembedded))
        addEmbeddedFonts(fm_embedded_fonts);
    };

    var initFileUpload = function () {
        if (env.filereader) {
            // init file upload form
            $(cfg.id.file).change(function (event) {
                addUploadedFonts(event.target.files);
            });
            $(cfg.id.file_browse_button).click(function (event) {
                event.preventDefault();
                $(cfg.id.file).click();
            });

            // init file drag and drop
            $(cfg.id.file_drop_zone).on("dragover", function (event) {
                event.stopPropagation();
                event.preventDefault();
                event.originalEvent.dataTransfer.dropEffect = 'copy';
            });
            $(cfg.id.file_drop_zone).on("drop", function (event) {
                event.stopPropagation();
                event.preventDefault();
                addUploadedFonts(event.originalEvent.dataTransfer.files);
            });
        } else {
            $(cfg.id.file_browse_button).click(function (event) {
                event.preventDefault();
                notify_alert("File upload is not supported by your browser, "
                    + "use embedded fonts instead");
            });
        }
    };

    var initRearrangeTab = function () {
        // init charset selection
        $(cfg.id.form_charset).find("input.fm-charset").change(function () {
            var charset = $(this).val();
            var content = $(cfg.id.tab2_content);
            if (charset == "basic_latin") {
                content.find("div.rg-top").each(function (index) {
                    // FIXME
                    if (cfg.basic_latin.str[index] == " ")
                        $(this).text("space");
                    else
                        $(this).text(cfg.basic_latin.str[index]);
                });
                content.find("div.rg-bottom").each(function (index) {
                    $(this).text(toUnicode(cfg.basic_latin.str[index]));
                });
                content.find("input.fm-unicode").each(function (index) {
                    $(this).val(cfg.basic_latin.str[index]);
                });
            } else {
                // FIXME
                content.find("div.rg-top").each(function (index) {
                    var c = (cfg.unicode_private.begin+index)
                        .toString(16).toUpperCase();
                    $(this).text("&#x"+c+";");
                });
                content.find("div.rg-bottom").each(function (index) {
                    var c = (cfg.unicode_private.begin+index)
                        .toString(16).toUpperCase();
                    $(this).text("U+"+c);
                });
                content.find("input.fm-unicode").each(function (index) {
                    var c = (cfg.unicode_private.begin+index)
                        .toString(16).toUpperCase();
                    $(this).val("&#x"+c+";");
                });
            }

            if (cfg.live_update) {
                updateFont();
                updateIconAssignments();
            }
        });
       
        // init drag and drop for rearrange icons
        for (var i=0, len=cfg.basic_latin.str.length; i<len; i++) {
            var tpl = $(cfg.template.rearrange_glyph.tpl).clone();

            var char = cfg.basic_latin.str[i];
            tpl.attr("id", "rgl"+i);
            tpl.find(".fm-unicode").attr("id", "rgu"+i).val(toCharRef(char));
            tpl.find(".rg-top").text(char != " " ? char : "space");
            tpl.find(".rg-bottom").text(toUnicode(char));
            tpl.find(".rg-icon").attr("id", "rgd"+i)
                .css({width: "100%", left: "0px", "margin-left": "0px"});
            tpl.find(".rg-icon").droppable($.extend({}, cfg.droppable_options, {
                drop: function (event, ui) {
                    console.log("drop");
                    $this=$(this);
                    var draggable=ui.draggable;
                    var g_id=$this.parent().siblings("input:checkbox")
                        .attr("value");
                    var d=$this.contents();

                    $this.parent().siblings("input:checkbox").attr({value:
                        draggable.parent().siblings("input:checkbox")
                            .attr("value")});
                    $this.empty().append(draggable.contents());

                    draggable.parent().siblings("input:checkbox")
                        .attr({value: g_id});
                    draggable.empty().append(d);

                    if (!$this.parent().parent().hasClass("selected")) {
                        $this.parent().parent().addClass("selected");
                        draggable.parent().parent().removeClass("selected");
                        $this.draggable(cfg.draggable_options);
                        draggable.draggable("disable");
                        $this.parent().siblings("input:checkbox")
                            .attr({checked: true});
                        draggable.parent().siblings("input:checkbox")
                            .attr({checked: false});
                    }

                    if (cfg.live_update) {
                        updateFont();
                        updateIconAssignments();
                    }
                }
            }));
            $(cfg.id.tab2_content).append(tpl);
        }
    };

    var initSaveTab = function () {
        initDownloadLink();
        initClipboardLinks();
    };

    var isOkBrowser = function () {
        // FF3.6+ Chrome6+ Opera11.1+
        var filereader = env.filereader = !!window.FileReader;

        // debug: simulate no filereader is available
        if (debug.is_on && debug.nofilereader)
            env.filereader = false;

        // FF4+ Chrome11+
        var indexeddb = env.indexeddb = Modernizr.indexeddb;

        // IE8+ FF3.5+ Chrome4+ Safari4+ Opera10.5+
        var localstorage = env.localstorage = Modernizr.localstorage;

        //FF3.5+ Chrome4+ Opera10.5+
        return (indexeddb || localstorage);
    };

    var initUseEmbedded = function () {
        for (var i=0, len=fm_embedded_fonts.length; i<len; i++) {
            var tpl = $(cfg.template.embedded.tpl).clone();
            var is_added = fm_embedded_fonts[i].is_added;
            var item = tpl.find(".fm-font-name");
            item.toggleClass("disabled", is_added)
                .data("embedded_id", i).
                text(fm_embedded_fonts[i].fontname);
            if (is_added) {
                item.off("click");
            } else {
                item.click(function (event) {
                    console.log("click Use Embedded");
                    var e_id = $(this).data("embedded_id");
                    console.assert(fm_embedded_fonts[e_id]);
                    if (fm_embedded_fonts[e_id])
                        addEmbeddedFonts([fm_embedded_fonts[e_id]]);
                });
            }
            $(cfg.id.use_embedded).append(tpl);
        }
    };

    var updateUseEmbedded = function () {
        console.log("updateUseEmbedded");
        $(cfg.id.use_embedded).empty();
        initUseEmbedded();
    };

    var Font = function () {
        if (this instanceof Font) {
            $.extend(this, arguments[0]);
        } else {
            var type = arguments[0];
            var data = arguments[1];

            switch (type) {
            case "svg":
                return Font.initSvg(data);

            case "cufonjs":
                return Font.initCufonJs(data);
            }

            return null;    //FIXME return Error object
        }
    };

    Font.initSvg = function (svg) {
        console.log("Font.initSvg");
        var font = {};

        var xml = null;
        try {
            xml = $.parseXML(svg);
        } catch (e) {
            console.log("Font.initSvg: invalid xml");
            return null; //FIXME return Error object
        }

        font.horiz_adv_x = parseInt($("font:first", xml).attr("horiz-adv-x"))
            || 1000;
        font.ascent = parseInt($("font-face:first", xml).attr("ascent")) || 750;
        font.descent = parseInt($("font-face:first", xml).attr("descent"))
                || -250;
        font.units_per_em = parseInt($("font-face:first", xml)
            .attr("units-per-em")) || 1000;
        font.id = $("font:first", xml).attr("id") || "unknown";

        font.glyphs = {};
        $("glyph", xml).filter(function (index) {
            // debug
            return debug.is_on && debug.maxglyphs && index < debug.maxglyphs
                || true;
        }).each(function (i) {
            var glyph = {};

            // FIXME
            glyph.horiz_adv_x = parseInt($(this).attr("horiz-adv-x"));
            glyph.d = $(this).attr("d");
            font.glyphs[i] = glyph;
        });

        return new Font(font);
    };

    Font.initCufonJs = function (js) {
        console.log("initCufonJs");
        var font = {};

        // strip function call
        var json_string = trimBoth(js, ".registerFont(", ")");

        var json = null;
        try {
            json = $.parseJSON(json_string);
        } catch (e) {
            console.log("Font.initCufonJs: invalid json");
            return null;    // FIXME return Error object
        }

        font.horiz_adv_x = json.w || 1000;
        font.ascent = json.face.ascent || 750;
        font.descent = json.face.descent || -250;
        font.units_per_em = json.face["units-per-em"] || 1000;
        font.id = json.face["font-family"] || "unknown";

        font.glyphs = {};
        var num_glyphs = 0;
        for (var i in json.glyphs) {
            num_glyphs++;
            // debug
            if (debug.is_on && debug.maxglyphs && debug.maxglyphs < num_glyphs)
                break;

            var glyph = {};

            if (json.glyphs[i].w)
                glyph.horiz_adv_x = json.glyphs[i].w;
            if (json.glyphs[i].d)
                // fix y coord and convert vml path to svg path
                glyph.d = vmlToSvgPath(vmlNegateY(json.glyphs[i].d));

            font.glyphs[i] = glyph;
        };

        return new Font(font);
    };

    var addEmbeddedFonts = function (embedded_fonts) {
        addFontsAsStrings(embedded_fonts, function (fileinfo) {
            // onload closure
            var e_id = fileinfo.embedded_id;
            addFont(fileinfo, function (fileinfo) {
                // onclose closure
                fm_embedded_fonts[e_id].is_added = fileinfo.is_added;
                updateUseEmbedded();
                updateGlyphCount();
            });
            fm_embedded_fonts[e_id].is_added = fileinfo.is_added;
            fm_embedded_fonts[e_id].fontname = fileinfo.fontname;
            updateUseEmbedded();
        });
    };

    var addUploadedFonts = function (files) {
        addFonts(files, function (fileinfo) {
            // onload closure
            addFont(fileinfo, function () {
                // onclose closure
                updateGlyphCount();
            });
        });
    };

    var addFontsAsStrings = function (files, cb_onload) {
        console.log("addFontsAsStrings files.length=", files.length);
        for (var i=0, f; f=files[i]; i++) {
            var idx = myfiles.push({
                id:             null,
                filename:       f.filename,
                filesize:       f.content.length,
                filetype:       f.filetype,
                fontname:       "unknown",
                is_loaded:      true,
                is_ok:          false,
                is_added:       false,
                is_dup:         false,
                error_msg:      "",
                content:        f.content,
                embedded_id:    f.id
            }) - 1;
            myfiles[idx].id = idx;

            if (cb_onload)
                cb_onload(myfiles[idx]);

            f.is_ok = myfiles[idx].is_ok;
            f.is_added = myfiles[idx].is_added;
            f.fontname = myfiles[idx].fontname;
        }
    };

    var addFonts = function (files, cb_onload) {
        console.log("addFonts");
        for (var i=0, f; f=files[i]; i++) {
            var idx = myfiles.push({
                id:             null,
                filename:       f.name,
                filesize:       f.size, 
                filetype:       f.type,
                fontname:       "unknown",
                is_loaded:      false,
                is_ok:          false,
                is_added:       false,
                is_dup:         false,
                error_msg:      "",
                content:        null,
                embedded_id:    null
            }) - 1;
            myfiles[idx].id = idx;

            var reader = new FileReader();
            reader.onload = (function (fileinfo) {
                return function (e) {
                    // FIXME: race condition?
                    // is there a file with the same content?
                    var is_exist = false;
                    for (var i=0, len=myfiles.length; i<len; i++) {
                        if (!myfiles[i] || !myfiles.is_ok)
                            continue;
                        if (myfiles[i].content == e.target.result) {
                            fileinfo.is_dup = is_exist = true;
                            break;
                        }
                    }
                    if (!is_exist) {
                        fileinfo.content = e.target.result;
                        fileinfo.is_loaded = true;
                    }

                    if (cb_onload)
                        cb_onload(fileinfo);
                };
            })(myfiles[idx]);
            reader.readAsBinaryString(f);
        }
    };

    var notify = function(text, tpl, extra_tpl_vars, extra_opts, suppress_dup) {
        var tpl_vars = {
            text: text
        };
        $.extend(tpl_vars, extra_tpl_vars);
        var options = extra_opts;

        if (suppress_dup && (text != undefined)) {
            if (cfg.notify.dup[text] != undefined) {
                console.log("notification suppressed");
                return;
            }

            cfg.notify.dup[text] = true;
            $.extend(options, {
                close: function () {
                    delete cfg.notify.dup[text];
                    console.log("notification can be fired again");
                }
            });
        }

        $(cfg.id.notification).notify("create", tpl, tpl_vars, options);
    };

    var notify_alert = function (text, suppress_dup) {
        notify(text,
            cfg.notify.alert.tpl,
            cfg.notify.alert.tpl_vars,
            cfg.notify.alert.opts, 
            suppress_dup
        );
    };

    var notify_info = function (text, suppress_dup) {
        notify(text,
            cfg.notify.info.tpl,
            cfg.notify.info.tpl_vars,
            cfg.notify.info.opts,
            suppress_dup
        );
    };

    var addFont = function (fileinfo, cb_onclose) {
        console.log("addFont id=", fileinfo.id);

        // if it is a dup, skip it
        if (fileinfo.is_dup)
            return;

        var font = null, types = ["svg"/*, "ttf", "otf"*/, "js"];

        var file_ext = getFileExt(fileinfo.filename);
        switch (file_ext) {
        case "svg":
            font = Font("svg", fileinfo.content);
            break;
        case "js":
            font = Font("cufonjs", fileinfo.content);
            break;
        default:
            // unknown file exstension
            notify_alert("Can't parse file '" + fileinfo.filename + "':"
                + " unknown file extension. Currently, we only support "
                + joinList(types, ", ", " and ") + "."
            );
            return;
        }

        if (!font) {
            console.log("invalid file");
            fileinfo.is_ok = false;
            fileinfo.error_msg = "invalid file";

            notify_alert("Loading error: can't parse file '" 
                + fileinfo.filename + "'");
            return;
        }

        fileinfo.is_ok = true;
        fileinfo.fontname = font.id;

        var div = cfg.id.select_glyphs;

        // FIXME
        $(cfg.id.tab1_content).find(".fm-glyph-id").off("click");

        var ascent = font.ascent,
            descent = font.descent,
            units_per_em = font.units_per_em;

        var size = parseInt($(cfg.id.icon_size).find("button.active").val())
            || 32;
        var font_size_y = Math.round(size * (ascent - descent) / units_per_em);
        
        // add a font
        var tpl_font = $(cfg.template.font.tpl).clone()
            .attr("id", "fm-font-"+fileinfo.id);
        tpl_font.find(".fm-font-name").text(fileinfo.fontname);
        tpl_font.find(".fm-font-anchor").attr("href", "#font-"+fileinfo.id);
        tpl_font.find(".fm-font-close").click(function (event) {
            removeFont(fileinfo);
            if (cb_onclose)
                cb_onclose(fileinfo);
        });
        $(cfg.id.tab1_content).append(tpl_font);

        // add a glyph-group
        var tpl_gg = $(cfg.template.glyph_group.tpl).clone();
        tpl_gg.addClass(cfg.icon_size_prefix+size);
        tpl_font.append(tpl_gg);

        // add glyphs to the glyph group
        var num_glyphs = 0;
        for (var i in font.glyphs) {
            num_glyphs++;
            // debug
            if (debug.is_on && debug.maxglyphs && debug.maxglyphs < num_glyphs)
                break;

            var horiz_adv_x = font.glyphs[i].horiz_adv_x || font.horiz_adv_x;
            var size_x = Math.round(size * horiz_adv_x / units_per_em),
                size_y = font_size_y;

            var tpl = $(cfg.template.glyph.tpl).clone();
            tpl.find(".fm-glyph-id").val(next_glyph_id);
            var gd = tpl.find(".gd");
            gd.attr("id", "gd"+next_glyph_id)
                .css({
                    width: size_x + "px",
                    height: size_y + "px",
                    "margin-left": "-" + Math.round(size_x/2) + "px",
                    "margin-top": "-" + Math.round(size_y/2) + "px"
                });
            $(tpl_gg).append(tpl);

            // add svg 
            var r = Raphael("gd"+next_glyph_id, size_x, size_y);
            var g = r.path(font.glyphs[i].d).attr(cfg.path_options);

            // calc delta_x, delta_y
            var bbox = g.getBBox();
            var delta_ascent = Math.max(0, (bbox.y + bbox.height) - ascent),
                delta_descent = Math.max(0, descent - bbox.y),
                delta_y = Math.max(delta_ascent, delta_descent);
            var delta_left = Math.max(0, 0 - bbox.x),
                delta_right = Math.max(0, (bbox.x + bbox.width) - horiz_adv_x),
                delta_x = Math.max(delta_left, delta_right);

            //debug
            gd.attr("bbox", bbox);

            // SVG's ViewBox
            var vb = {
                x: 0 - delta_x,
                y: descent - delta_y,
                w: horiz_adv_x + 2 * delta_x,
                h: (ascent - descent) + 2 * delta_y
            };

            // calc new size_y, size_x if glyph goes out of its default box
            if (delta_y > 0) {
                size_y = Math.round(size * (ascent - descent + 2 * delta_y)
                    / units_per_em );
            }
            if (delta_x > 0) {
                size_x = Math.round(size * (horiz_adv_x + 2 * delta_x)
                    / units_per_em);
            }

            // FIXME: hack to avoid clipped edges by adding 1 pixel on
            // each side and adjusting viewbox accordingly
            if (cfg.fix_edges) {
                var delta_xx = vb.w / size_x, 
                    delta_yy = vb.h / size_y;

                vb.x -= delta_xx;
                vb.y -= delta_yy;
                vb.w += 2 * delta_xx;
                vb.h += 2 * delta_yy;

                size_x += 2;
                size_y += 2;
            }

            // set new size
            if (cfg.fix_edges || delta_x > 0 || delta_y > 0) {
                r.setSize(size_x, size_y);

                gd.css({
                    width: size_x + "px",
                    height: size_y + "px",
                    "margin-left": "-" + Math.round(size_x/2) + "px",
                    "margin-top": "-" + Math.round(size_y/2) + "px"
                });
            }

            r.setViewBox(vb.x, vb.y, vb.w, vb.h, true);

            // flip y
            // debug: turn flip off 
            if (!(debug && debug.noflip)) {
            // FIXME
            var flip_y_matrix = [1, 0, 0, -1, 0, ascent / 2 - descent];
            g.attr({transform: "m" + flip_y_matrix});
            }

            g.show();

            // precalc glyph sizes
            // FIXME: precalc only if glyph goes out of its default box
            var glyph_sizes = {};
            for (var j in cfg.preview_icon_sizes) {
                var icon_size = cfg.preview_icon_sizes[j];
                size_y = Math.round(icon_size * (ascent - descent + 2 * delta_y)
                    / units_per_em);
                size_x = Math.round(icon_size * (horiz_adv_x + 2 * delta_x)
                    / units_per_em);
                glyph_sizes[icon_size] = [size_x, size_y];
            }

            myglyphs[next_glyph_id] = {
                dom_node: $("<glyphs/>").attr("d", font.glyphs[i].d),
                file_id: fileinfo.id,
                glyph_sizes: glyph_sizes,
                units_per_em: units_per_em  // FIXME: move it to fileinfo
            };
            next_glyph_id++;
        }

        $(cfg.id.tab1_content).find(".fm-glyph-id").click(function (event) {
            $(this).parent().toggleClass("selected", $(this).is(":checked"));
            toggleGlyph($(this).attr("value"), $(this).is(":checked"));

            if (cfg.live_update) {
                updateFont();
                updateIconAssignments();
            }
        });

        fileinfo.is_added = true;

        // scroll to the loaded font
/*
        var fonthash = 'a[href="#font-'+fileinfo.id+'"]';
        $("html,body").animate({scrollTop: $(fonthash).offset().top}, 500);
*/
    };

    var vmlToSvgPath = function (vml) {
        var path = "";
        if (vml)
            path = "M" + vml.replace(/[mlcxtrv]/g, function (command) {
                return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command]
                    || "M";
            }) + "z";
        return path;
    };

    var vmlNegateY = function (vml) {
        if (!vml)
            return vml;

        var result = "", re = /^([^a-z]*)/, re2 = /([mrvxe])([^a-z]*)/g, match;
        match = re.exec(vml);
        var c = match[1].split(',');
        c = c.map(function(value, idx) {
            return idx % 2 == 1 ? -value : value
        });
        result += c.join(",");
        
        for (var i = 0; match = re2.exec(vml); ++i) {
            var c = match[2].split(',');
            c = c.map(function(value, idx) {
                return idx % 2 == 1 ? -value : value
            });
            result += match[1]+c.join(",");
        }
        return result;
    };

    var removeFont = function (fileinfo) {
        console.log("removeFont id=", fileinfo.id);

        var file_id = fileinfo.id;

        // free mem
        for (var i=0, len=myglyphs.length; i<len; i++) {
            if (myglyphs[i].file_id == file_id) {
                $(myglyphs[i].dom_node).remove();
                myglyphs[i].file_id = -1;   // null?
            }
        }
        myfiles[file_id] = null;

        // remove associated html markup
        var font = $('#fm-font-'+file_id);
        font.find("input:checkbox:checked").each(function() {
            var glyph_id = $(this).val();
            removeGlyph(glyph_id);
        });
        font.remove();

        fileinfo.is_added = false;
    };

    var updateGlyphCount = function () {
        $(cfg.id.glyph_count).text(glyph_count);
    };

    var toggleGlyph = function (g_id, is_checked) {
        if (is_checked)
            addGlyph(g_id);
        else
            removeGlyph(g_id);
        updateGlyphCount();
    };

    // add a glyph to the rearrange zone
    var addGlyph = function (g_id) {
        console.log("addGlyph g_id=", g_id);
        var checkbox=$(cfg.id.tab2_content)
            .find(".fm-glyph-id:not(:checked):first");
        checkbox.attr({value: g_id, checked: true});
        checkbox.parent().addClass("selected");
        var svg = $("#gd"+g_id).contents().clone(false);
        var icon = checkbox.parent().find(".rg-icon");
        icon.append(svg)
            .draggable(cfg.draggable_options)
            .attr("style", $("#gd"+g_id).attr("style"))
            .css({width: "100%", left: "0px", "margin-left": "0px"});

        if (glyph_count == 0)
            toggleMenu(true);
        glyph_count++;
    };

    // remove a glyph from the rearrange zone
    var removeGlyph = function (g_id) {
        console.log("removeGlyph g_id=", g_id);
        var checkbox=$(cfg.id.tab2_content)
            .find(".fm-glyph-id:checked[value='"+g_id+"']");
        checkbox.attr({value: "", checked: false});
        checkbox.parent().removeClass("selected");
        checkbox.parent().find(".rg-icon").empty();

        if (glyph_count == 1)
            toggleMenu(false);
        glyph_count--;
        console.assert(glyph_count >= 0);
    };

    var toggleMenu = function (enabled) {
        console.log("toggleMenu");
        $(cfg.id.tab).find("a"+cfg.class.disable_on_demand)
            .toggleClass("disabled", !enabled);
    };

    // update font's textarea
    var updateFont = function () {
        if (!xml_template)
            return;

        var glyphs = [];
        $(cfg.id.tab2_content)
            .find("input:checkbox:checked")
            .each(function () {
                var $this = $(this);
                var g_id = $this.val();
                var unicode = $this.siblings("input.fm-unicode").val();
                if (!myglyphs[g_id]) {
                    console.log("undefined myglyphs[", g_id, "]");
                    return; 
                }
                var g = $(myglyphs[g_id].dom_node).clone();
                g.attr("unicode", unicode);
                if (myglyphs[g_id].units_per_em != cfg.output.units_per_em) {
                    var scale = cfg.output.units_per_em
                        / myglyphs[g_id].units_per_em;
                    g.attr("d", scalePath(g.attr("d"), scale));
                }
                glyphs.push(outerHtml(g));
            });
        $("glyph", xml_template).remove();
        $("font", xml_template).append($(glyphs.join("\n")));
        $(cfg.id.font).text(xmlToString(xml_template));
    };

    var scalePath = function (path, scale) {
        path = path.replace(/(-?\d*\.?\d*(?:e[\-+]?\d+)?)/ig, function (num) {
            num = (parseFloat(num) * scale).toPrecision(cfg.scale_precision);
            num = parseFloat(num);  // extra parseFloat to strip trailing zeros
            return isNaN(num) ? "" : num;
        });
        return path;
    };

    var initDownloadLink = function () {
        console.log("initDownloadLink");

        $(cfg.id.tab_save).one("shown", function () {
            console.log("initDownloadLink: shown fired");
            // flash download helper doesn't work if file: proto used
            if (!env.is_file_proto && env.flash_version.major > 0) {
                $(cfg.id.download_font_button).downloadify({
                    swf: "img/downloadify.swf",
                    downloadImage: "img/transparent-129x140.png",
                    width: $(cfg.id.download_font_button).outerWidth(),
                    height: $(cfg.id.download_font_button).outerHeight(),
                    filename: cfg.output.filename,
                    data: function () {
/*
                        var zip = new JSZip();
                        zip.add("font.svg", $(cfg.id.font).val());
                        return zip.generate();
*/
                        return $(cfg.id.font).val();
                    },
                    dataType: "string",
                    transparent: true,
                    append: true,
                    onComplete: function () {
                        console.log("downloadify onComplete");
                    },
                    onCancel: function () {
                        console.log("downloadify onCancel");
                    },
                    onError: function () {
                        console.log("downloadify onError");
                    }
                });
            } else {
                $(cfg.id.download_font_button).click(function (event) {
                    console.log("noflash download button clicked");

                    // image/svg+xml
                    // binary/octet-stream
                    // application/x-zip-compressed
/*
                    var zip = new JSZip();
                    zip.add("font.svg", $(cfg.id.font).val());
                    location.href = "data:application/zip;base64,"
                        + zip.generate();
*/
                    $(cfg.id.download_font_button).attr({
                        download: cfg.output.filename,
                        href: "data:binary/octet-stream;base64,"
                            + base64_encode($(cfg.id.font).val())
                    });

                });
            }
        });
    };

    var initClipboardLinks = function () {
        console.log("initClipboardLinks");

        $(cfg.id.tab_save).one("shown", function () {
            console.log("initClipboardLinks: shown fired");
            // flash clipboard helper doesn't work if file: proto used
            if (!env.is_file_proto && env.flash_version.major > 0) {
                ZeroClipboard.setMoviePath(cfg.zero_clipboard.swf_path);

                for (var i=0, len=cfg.zero_clipboard.links.length; i<len; i++) {
                    var item=cfg.zero_clipboard.links[i];
                    item.client = new ZeroClipboard.Client();
                    item.client.fm_index = i;
                    item.client.glue(item.link, item.span);

                    item.client.addEventListener("mouseDown", function (client) { 
                        console.log("zcb: mousedown");
                        var item=cfg.zero_clipboard.links[client.fm_index];
                        client.setText($(item.target).val());
                    });
                    item.client.addEventListener("complete",
                        function (client, text) {
                            console.log("zcb: complete");
                            notify_info("Copied to clipboard", true);
                        }
                    );
                    item.client.addEventListener("mouseOver",
                        function (client) {
                            console.log("zcb: mouseover");
                            $("#"+item.link).trigger("mouseover");
                        }
                    );
                    item.client.addEventListener("mouseOut",
                        function (client) { 
                            console.log("zcb: mouseout");
                            $("#"+item.link).trigger("mouseout");
                        }
                    );

                    $("#"+item.link).click(function () {
                        console.log("noflash clipboard link clicked");
                    });
                }
/*
            } else {
                // TODO: IE clipboard code
*/
            } else {
                // no clipboard support
                for (var i=0, len=cfg.zero_clipboard.links.length; i<len; i++) {
                    var item=cfg.zero_clipboard.links[i];
                    $("#"+item.span).remove();
                }
            }
        });
    };

    // update IA's textarea
    var updateIconAssignments = function () {
        var lines = [];
        lines.push(
            "/*",
            "", 
            "Name                       Hex entity          CSS content",
            "======================================================================"
        );

        $(cfg.id.tab2_content)
            .find("input:checkbox:checked")
            .each(function () {
                var $this = $(this);
                var g_id = $this.val();
                var unicode = $this.siblings("input.fm-unicode").val();
                var tmp = toEntityAndCss(unicode);
                lines.push(
                    rpad("n/a", 32)
                    +rpad(tmp.entity, 20)
                    +tmp.css
                );
            });
        lines.push("", "*/");
        $(cfg.id.icon_assignments).text(lines.join("\n"));
    }

    // ===============
    // misc functions
    // ===============
    var outerHtml = function (jquery_object) {
        return $("<div/>").append(jquery_object.clone()).html();
    };

    var xmlToString = function(xmlDom) {
        // cross-browser
        var result = (typeof XMLSerializer!=="undefined")
            ? (new window.XMLSerializer()).serializeToString(xmlDom)
            : xmlDom.xml;
        //FIXME: quickfix: add xml declaration
        result = '<?xml version="1.0" standalone="no"?>\n' + result;
        //FIXME: quickfix: get rid of unwanted xmlns insertion
        result = result.replace(/ xmlns="http:\/\/www\.w3\.org\/1999\/xhtml"/g,
            "");
        //FIXME: quickfix: remove the extra newlines
        result = result.replace(/>(\s)*<glyph/gm, ">\n<glyph");
        //FIXME: quickfix: &amp; => &
        result = result.replace(/&amp;#x/gm, "&#x");
        return result;
    };

    // return char in CharRef notation
    var toCharRef = function (char) {
        return "&#x" + char.charCodeAt(0).toString(16) + ";";
    };

    // return char in U+ notation
    var toUnicode = function (char) {
        var c = char.charCodeAt(0).toString(16).toUpperCase();
        if (c.length < 4)
            c = "0000".substr(0, 4-c.length) + c;
        return "U+" + c;
    };

    //FIXME
    var toEntityAndCss = function (char) {
        var code = char.charCodeAt(0);
        if (32 <= code && code <= 127)
            return {
                entity: char,
                css: "content: '"+char+"';"
            };
        else
            return {
                entity: toCharRef(char),
                css: "content: '\\"+code.toString(16)+"';"
            };  
    };

    var getFileExt = function (filepath) {
        var defaultval = "";
        if (!is_string(filepath))
            return defaultval;

        var index = filepath.lastIndexOf(".");
        if (index == -1)
            return defaultval;
        else
            return filepath.substr(index+1).toLowerCase();
    };

    var joinList = function (array, delim1, delim2) {
        return array.reduce(function (prev, cur, idx, arr) {
            return arr.length != idx+1
                ? prev + delim1 + cur
                : prev + delim2 + cur;
        });
    };

    // type functions
    var is_string = function (s) {
        return typeof s == "string";
    }

    // string functions

    // trim string at both sides:
    // in:  s="abc{hello}def", begin="c{", end="}"
    // out: "hello"
    var trimBoth = function (s, begin, end) {
        var idx1 = s.indexOf(begin) + begin.length,
            idx2 = s.lastIndexOf(end);
        if (idx1 < idx2)
            return s.substr(idx1, idx2 - idx1);
        else
            return s;
    };

    var randomNumString = function (len) {
        var result = "";
        for (var i=0; i<(len/8)+1; i++) {
            result += Math.round(Math.random()*89999999+10000000).toString(10);
        }
        return result.substr(0, len); 
    };

    var repeat = function (s, times) {
        if (times < 1)
            return "";
        var result = "";
        while (times > 0) {
            if (times & 1)
                result += s;
            times >>= 1;
            s += s;
        }
        return result; 
    };

    var rpad = function (s, len) {
        if (s.length < len)
            return s + repeat(" ", len - s.length);
        else
            return s;
    };

    var lpad = function (s, len) {
        if (s.length < len)
            return repeat(" ", len - s.length) + s;
        else
            return s;
    };

    var base64_encode = function (s) {
        var table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var result = "";

        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;

        for (var i=0, len=s.length; i<len; i+=3) {
            chr1 = s.charCodeAt(i);
            chr2 = s.charCodeAt(i+1);
            chr3 = s.charCodeAt(i+2);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            result += table.charAt(enc1) + table.charAt(enc2)
                + table.charAt(enc3) + table.charAt(enc4);
        }

        return result;
    };

    // public interface
    return {
        init: init
    };
})();

$(document).ready(function () {
    myapp.init();
});
