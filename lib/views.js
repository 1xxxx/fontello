/**
 *  Views
 *
 *  A collection of tools to process (compile, localize etc.) view files.
 **/


/*global underscore, N*/


'use strict';


// stdlib
var fs    = require('fs');
var path  = require('path');


// 3rd-party
var _         = underscore;
var async     = require('async');
var fstools   = require('fs-tools');


// internal
var engines       = require('./views/engines');
var support       = require('./support');
var apify         = require('./support').apify;
var safePropName  = require('./support').safePropName;


////////////////////////////////////////////////////////////////////////////////


/**
 *  Views.localize(source, output, i18n, locales, callback) -> Void
 *  - source (String): Path where your views are placed.
 *  - output (String): Path where to put localized views.
 *  - i18n (Babelfish): Instance of BabelFish translator.
 *  - locales (Array): List of locales you want to produce localized views for.
 *  - callback (Function): Executed once everything is done.
 *
 *  Pre-localizes view templates by replacing all calls to the `t()` helper for
 *  phrases that contains no macroses with resulting strings.
 *
 *
 *  ##### Example
 *
 *  Assume you have following structure of view files:
 *
 *      /path/to-my/source-views/foo/bar.jade
 *      /path/to-my/source-views/baz.jade
 *
 *  After executing this method with `locales = ['en', 'ru']` you will receive:
 *
 *      /path/to-my/output-views/en/foo/bar.jade
 *      /path/to-my/output-views/en/baz.jade
 *      /path/to-my/output-views/ru/foo/bar.jade
 *      /path/to-my/output-views/ru/baz.jade
 **/
function localize(source, output, i18n, locales, callback) {
  // TODO: Views localization is stubbed and needs real implementation
  async.series([
    async.apply(fstools.mkdir, output),
    function (next) {
      async.forEach(locales, function (locale, nextLocale) {
        fstools.copy(source, path.join(output, locale), nextLocale);
      }, next);
    }
  ], function (err/*, results */) {
    callback(err);
  });
}


// internal
// ENGINES_RE -> RegExp
//
// Mathes filenames that can be processed with template engines we know.
// Example: /(?:jade|ejs|html)$/
//
var ENGINES_RE = new RegExp(
  '[.](?:' +
  _.keys(engines).map(function (ext) {
    return ext.replace('.', '');
  }).join('|') +
  ')$'
);


/**
 *  Views.collect(pathnames, callback(err, views)) -> Void
 *  - pathnames (String|Array): Path(s) where view files are placed.
 *  - callback (Function): Executed once all files were processed.
 *
 *  Collects all view files under the `pathname` and builds a map of pairs:
 *
 *      // apiPath -> client/server template renderer
 *      "foo.bar": {
 *        client: "function (locals) { return 'example' };",
 *        server: function (locals) { return 'example'; }
 *      }
 *
 *
 *  ##### See Also:
 *
 *  - [[Views.buildClientTree]]
 *  - [[Views.buildServerTree]]
 **/
function collect(pathnames, callback) {
  var views = {};

  pathnames = _.isArray(pathnames) ? pathnames : [pathnames];

  async.forEach(pathnames, function (pathname, nextPath) {
    fstools.walk(pathname, ENGINES_RE, function (filename, lstats, nextFile) {
      var ext = path.extname(filename),
          api = apify(filename, pathname, new RegExp('\\.' + ext.substr(1) + '$'));

      async.waterfall([
        async.apply(fs.readFile, filename, 'utf8'),
        function (str, next) {
          // get compiled server and client functions
          async.series([
            async.apply(engines[ext].server, str, { filename: filename }),
            async.apply(engines[ext].client, str, { filename: filename })
          ], next);
        },
        function (results, next) {
          views[api] = { server: results[0], client: results[1] };
          next();
        }
      ], nextFile);
    }, nextPath);
  }, function (err) {
    callback(err, views);
  });
}


/**
 *  Views.buildServerTree(views) -> Object
 *  - views (Object): Views map generated by [[Views.collect]].
 *
 *  Returns a fully populated tree object with given views.
 *
 *
 *  ##### Example
 *
 *      collect('/path/to/views', function (err, views) {
 *        // ...
 *        N.views = buildServerTree(views);
 *        // ...
 *      });
 **/
function buildServerTree(views) {
  var tree = {};

  _.keys(views).sort().forEach(function (api) {
    support.tree.set(tree, api, views[api].server);
  });

  return tree;
}


/**
 *  Views.buildClientTree(views[, namespace = 'this.views']) -> String
 *  - views (Object): Views map generated by [[Views.collect]].
 *  - namespace (String): Global object used as container for the tree.
 *
 *  Returns a browserified function that will create views tree and will
 *  inject it into the `namespace`.
 *
 *
 *  ##### Example
 *
 *      collect('/path/to/views', function (err, views) {
 *        // ...
 *        var output = buildClientTree(views, 'this.appViews');
 *        fs.writeFile('/path/to/client.js', output);
 *        // ...
 *      });
 **/
function buildClientTree(views, namespace) {
  var keys = _.keys(views), head = [], body = [];

  //
  // generate structure needed to build the tree
  //

  keys.forEach(function (api) {
    var parts = api.split('.').map(safePropName);

    // the last element is the function itself, so skip it
    parts.pop();

    while (parts.length) {
      head.push('this' + parts.join(''));
      parts.pop();
    }
  });

  head = _.uniq(head.sort(), true).map(function (ns) {
    return 'if (!' + ns + ') { ' + ns + ' = {}; }';
  });

  //
  // generate tree population with functions
  //

  keys.sort().forEach(function (api) {
    body.push('this' + api.split('.').map(safePropName).join('') +
              ' = ' + views[api].client);
  });

  //
  // Return tree populator
  //


  namespace = namespace || 'this.views';

  return  '(function () {\n' +
          head.join('\n') + '\n' + body.join('\n') +
          '\n}.call(' + namespace + ' || (' + namespace + ' = {})));';
}


/**
 *  Views.writeClientTree(filename, views[, namespace], callback(err)) -> String
 *  - filename (String): Filename where to write built views tree.
 *  - views (Object): Views map generated by [[Views.collect]].
 *  - namespace (String): Global object used as container for the tree.
 *  - callback (Function): Executed once everything is done.
 *
 *  Build client-side `views` tree populator and writes it into the `filename`
 *  creating parent directories if needed.
 *
 *
 *  ##### Example
 *
 *      collect('/path/to/views', function (err, views) {
 *        // ...
 *        writeClientTree('/path/to/client.js', views, function (err) {
 *          // ... syntax sugar is sweet ...
 *        });
 *      });
 *
 *
 *  ##### See Also
 *
 *  - [[Views.buildClientTree]]
 **/
function writeClientTree(filename, tree, namespace, callback) {
  if (!callback) {
    callback  = namespace;
    namespace = null;
  }

  fstools.mkdir(path.dirname(filename), function (err) {
    var str;

    if (err) {
      callback(err);
      return;
    }

    try {
      str = buildClientTree(tree, namespace);
    } catch (err) {
      callback(err);
      return;
    }

    fs.writeFile(filename, str, 'utf8', callback);
  });
}


////////////////////////////////////////////////////////////////////////////////


module.exports.engines          = engines;
module.exports.localize         = localize;
module.exports.collect          = collect;
module.exports.buildServerTree  = buildServerTree;
module.exports.buildClientTree  = buildClientTree;
module.exports.writeClientTree  = writeClientTree;
